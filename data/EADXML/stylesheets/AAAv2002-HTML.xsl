<!-- stephboxfolder generated by Steph 6/05 using Loren's stylesheet generated by Loren 1/31/02 from E AD Cookbook Style 2 and Michael Fox's changes to the container list Version 0.9   2000 July 22; incorporating changes attempting to accomodate EAD Cookbook v. 2  -->
<!--  This stylesheet generates Style 2 and Michael Fox's addition for boxes and folders which has a Table of Contents in an HTML table cell along the left side of the screen. It may be used when an HTML frame is not desired.  -->
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns="http://www.w3.org/1999/xhtml" version="1.0">
<xsl:output method="xml" indent="yes" encoding="UTF-8"/>
<xsl:strip-space elements="*"/>

<!-- Creates the body of the finding aid.-->
<xsl:template match="/">
	<html>
		<head>
			<xsl:call-template name="head"/>
		</head>
	
	
		<body>
			<table width="100%" cellpadding="5">
				<tr><td width="20%"></td><td width="80%"></td></tr>
				<tr>
					<td valign="top" bgcolor="#CCCCCC"><xsl:call-template name="toc"/></td>
					<td valign="top" bgcolor="#FFFFFF">
						<!-- The ead header contains the cover page information -->
						<xsl:call-template name="cover"/>
						<xsl:call-template name="archdesc-did"/>
						<xsl:call-template name="archdesc-admininfo"/>
						<xsl:call-template name="archdesc-bioghist"/>
						<xsl:call-template name="archdesc-scopecontent"/>
						<xsl:call-template name="archdesc-control"/>
						<xsl:call-template name="archdesc-arrangement"/>
						<xsl:call-template name="archdesc-otherfindaid"/>
						<xsl:call-template name="dsc"/>
						<xsl:call-template name="archdesc-odd"/>
						<xsl:call-template name="archdesc-bibliography"/>
					</td>
				</tr>
			</table>
		</body>
	</html>
</xsl:template>

	<xsl:template name="head">
		<style> h1, h2, h3, h4 {font-family: arial}</style> 
		<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
		<title>
			<xsl:value-of select="ead/eadheader/filedesc/titlestmt/subtitle" />
		</title>
		<xsl:element name="meta">
			<xsl:attribute name="name">dc.title</xsl:attribute>
			<xsl:attribute name="content"><xsl:value-of select="ead/eadheader/filedesc/titlestmt/titleproper" /><xsl:text> </xsl:text><xsl:value-of select="ead/eadheader/filedesc/titlestmt/subtitle" /></xsl:attribute>
		</xsl:element>
		<xsl:element name="meta">
			<xsl:attribute name="name">dc.author</xsl:attribute>
			<xsl:attribute name="content"><xsl:value-of select="ead/archdesc/did/origination" /></xsl:attribute>
		</xsl:element>
		<xsl:for-each select="ead//controlaccess/persname | ead//controlaccess/corpname">
			<xsl:choose>
				<xsl:when test="@encodinganalog='600'">
					<xsl:element name="meta">
						<xsl:attribute name="name">dc.subject</xsl:attribute>
						<xsl:attribute name="content"><xsl:value-of select="." /></xsl:attribute>
					</xsl:element>
				</xsl:when>
				<xsl:when test="@encodinganalog='610'">
					<xsl:element name="meta">
						<xsl:attribute name="name">dc.subject</xsl:attribute>
						<xsl:attribute name="content"><xsl:value-of select="." /></xsl:attribute>
					</xsl:element>
				</xsl:when>
				<xsl:when test="@encodinganalog='611'">
					<xsl:element name="meta">
						<xsl:attribute name="name">dc.subject</xsl:attribute>
						<xsl:attribute name="content"><xsl:value-of select="." /></xsl:attribute>
					</xsl:element>
				</xsl:when>
				<xsl:when test="@encodinganalog='700'">
					<xsl:element name="meta">
						<xsl:attribute name="name">dc.contributor</xsl:attribute>
						<xsl:attribute name="content"><xsl:value-of select="." /></xsl:attribute>
					</xsl:element>
				</xsl:when>
				<xsl:when test="@encodinganalog='710'">
					<xsl:element name="meta">
						<xsl:attribute name="name">dc.contributor</xsl:attribute>
						<xsl:attribute name="content"><xsl:value-of select="." /></xsl:attribute>
					</xsl:element>
				</xsl:when>
				<xsl:when test="@encodinganalog='711'">
					<xsl:element name="meta">
						<xsl:attribute name="name">dc.contributor</xsl:attribute>
						<xsl:attribute name="content"><xsl:value-of select="." /></xsl:attribute>
					</xsl:element>
				</xsl:when>
				<xsl:otherwise>
					<xsl:element name="meta">
						<xsl:attribute name="name">dc.contributor</xsl:attribute>
						<xsl:attribute name="content"><xsl:value-of select="." /></xsl:attribute>
					</xsl:element>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:for-each>
		<xsl:for-each select="ead//controlaccess/subject">
			<xsl:element name="meta">
				<xsl:attribute name="name">dc.subject</xsl:attribute>
				<xsl:attribute name="content"><xsl:value-of select="." /></xsl:attribute>
			</xsl:element>
		</xsl:for-each>
		<xsl:element name="meta">
			<xsl:attribute name="name">dc.title</xsl:attribute>
			<xsl:attribute name="content"><xsl:value-of select="ead/archdesc/did/unittitle" /></xsl:attribute>
		</xsl:element>
		<xsl:element name="meta">
			<xsl:attribute name="name">dc.type</xsl:attribute>
			<xsl:attribute name="content">text</xsl:attribute>
		</xsl:element>
		<xsl:element name="meta">
			<xsl:attribute name="name">dc.format</xsl:attribute>
			<xsl:attribute name="content">manuscripts</xsl:attribute>
		</xsl:element>
		<xsl:element name="meta">
			<xsl:attribute name="name">dc.format</xsl:attribute>
			<xsl:attribute name="content">finding aids</xsl:attribute>
		</xsl:element>
		<xsl:for-each select="ead//controlaccess/geogname">
			<xsl:element name="meta">
				<xsl:attribute name="name">dc.coverage</xsl:attribute>
				<xsl:attribute name="content"><xsl:value-of select="." /></xsl:attribute>
			</xsl:element>
		</xsl:for-each>
	</xsl:template>

<xsl:template name="toc">
	<xsl:variable name="file">
		<xsl:value-of select="ead/eadheader/eadid" />
	</xsl:variable>
	<h3>
		TABLE OF CONTENTS
	</h3>
	<br>
	</br>
	<xsl:if test="ead/archdesc/did">
		<p>
			<b>
				<a href="#a1">
					<xsl:value-of select="ead/archdesc/did/head" />
				</a>
			</b>
		</p>
	</xsl:if>
	<xsl:if test="ead/archdesc/acqinfo[string-length(text()|*)!=0] | ead/archdesc/separatedmaterial[string-length(text()|*)!=0] | ead/archdesc/originalsloc[string-length(text()|*)!=0] | ead/archdesc/relatedmaterial[string-length(text()|*)!=0] | ead/archdesc/processinfo[string-length(text()|*)!=0] | ead/archdesc/altformavail[string-length(text()|*)!=0] | ead/archdesc/prefercite[string-length(text()|*)!=0] | ead/archdesc/accessrestrict[string-length(text()|*)!=0] | ead/archdesc/userestrict[string-length(text()|*)!=0] | ead/archdesc/custodialhist[string-length(text()|*)!=0] | ead/archdesc/appraisal[string-length(text()|*)!=0] | ead/archdesc/accruals[string-length(text()|*)!=0]">
	</xsl:if>
	<xsl:if test="ead/archdesc/acqinfo[string-length(text()|*)!=0] | ead/archdesc/separatedmaterial[string-length(text()|*)!=0] | ead/archdesc/originalsloc[string-length(text()|*)!=0] | ead/archdesc/relatedmaterial[string-length(text()|*)!=0] | ead/archdesc/processinfo[string-length(text()|*)!=0] | ead/archdesc/altformavail[string-length(text()|*)!=0] | ead/archdesc/prefercite[string-length(text()|*)!=0] | ead/archdesc/accessrestrict[string-length(text()|*)!=0] | ead/archdesc/userestrict[string-length(text()|*)!=0] | ead/archdesc/custodialhist[string-length(text()|*)!=0] | ead/archdesc/appraisal[string-length(text()|*)!=0] | ead/archdesc/accruals[string-length(text()|*)!=0]">
		<p style="margin-top:-5pt">
			<b>
				<a href="#a14">
					<xsl:text>
						Administrative Information
					</xsl:text>
				</a>
			</b>
		</p>
	</xsl:if>
	<xsl:if test="ead/archdesc/bioghist[string-length(text()|*)!=0]">
		<p style="margin-top:-5pt">
			<b>
				<a href="#a2">
					<xsl:value-of select="ead/archdesc/bioghist/head" />
				</a>
			</b>
		</p>
	</xsl:if>
	<xsl:if test="ead/archdesc/scopecontent[string-length(text()|*)!=0]">
		<p style="margin-top:-5pt">
			<b>
				<a href="#a3">
					<xsl:value-of select="ead/archdesc/scopecontent/head" />
				</a>
			</b>
		</p>
	</xsl:if>
	<xsl:if test="ead/archdesc/arrangement[string-length(text()|*)!=0]">
		<p style="margin-top:-5pt">
			<b>
				<a href="#a4">
					<xsl:value-of select="ead/archdesc/arrangement/head" />
				</a>
			</b>
		</p>
	</xsl:if>
	<xsl:if test="ead/archdesc/controlaccess[string-length(text()|*)!=0]">
		<p style="margin-top:-5pt">
			<b>
				<a href="#a12">
					<xsl:value-of select="ead/archdesc/controlaccess/head" />
				</a>
			</b>
		</p>
	</xsl:if>
	<xsl:if test="ead/archdesc/dsc[string-length(text()|*)!=0]">
		<a href="#a23">
			<p style="margin-top:-5pt">
				<b>
					<xsl:value-of select="ead/archdesc/dsc/head" />
				</b>
			</p>
		</a>
		<xsl:for-each select="ead/archdesc/dsc/c01">
			<p style="margin-left:10pt; margin-top:-5pt">
				<b>
					<font size="-1">
						<a>
							<xsl:attribute name="href">
								#series
								<xsl:number value="position()" format="1" />
							</xsl:attribute>
							<xsl:choose>
								<xsl:when test="did/unittitle/unitdate">
									<xsl:for-each select="did/unittitle">
										<xsl:apply-templates select="." />
									</xsl:for-each>
								</xsl:when>
								<xsl:otherwise>
									<xsl:apply-templates select="did/unittitle" />
									<xsl:text>
									</xsl:text>
									<xsl:apply-templates select="did/unitdate" />
								</xsl:otherwise>
							</xsl:choose>
						</a>
					</font>
				</b>
			</p>
		</xsl:for-each>
		<xsl:for-each select="//odd">
			<xsl:if test="//odd[string-length(text()|*)!=0]/head">
				<p style="margin-top:-5pt">
					<b>
						<a href="#{@id}"><xsl:value-of select="head" /></a>
					</b>
				</p>
			</xsl:if>
		</xsl:for-each>
		<xsl:if test="ead/archdesc/otherfindaid[string-length(text()|*)!=0]">
			<p style="margin-top:-5pt">
				<b>
					<a href="#a10">
						<xsl:value-of select="ead/archdesc/otherfindaid/head" />
					</a>
				</b>
			</p>
		</xsl:if>
		<xsl:if test="ead/archdesc/index[string-length(text()|*)!=0]">
			<p style="margin-top:-5pt">
				<b>
					<a href="#a9">
						<xsl:value-of select="ead/archdesc/index/head" />
					</a>
				</b>
			</p>
		</xsl:if>
		<xsl:if test="ead/archdesc/bibliography[string-length(text()|*)!=0]">
			<p style="margin-top:-5pt">
				<b>
					<a href="#a10">
						<xsl:value-of select="ead/archdesc/bibliography/head" />
					</a>
				</b>
			</p>
		</xsl:if>
	</xsl:if>
</xsl:template>

<xsl:template name="cover">
	<xsl:for-each select="ead/eadheader/filedesc/titlestmt">
		<p style="text-align:center">
			<a name="a0">
				<img src="../../images/website/36aaa.gif"></img>
			</a>
		</p>
		<xsl:if test="string-length(titleproper)">
			<h1 align="center">
				<xsl:value-of select="titleproper"/>
			</h1>				
		</xsl:if>
		<h2 align="center">
			<xsl:value-of select="subtitle"/>
		</h2>
		<!-- Loren added Author and Address info -->
		<h3 align="center">
			<xsl:value-of select="author"/>
		</h3>
		<xsl:if test="string-length(sponsor)">
			<h4 align="center">
				<xsl:value-of select="sponsor"/>
			</h4>
		</xsl:if>
	</xsl:for-each>
	
	<h5 align="center">
		<xsl:value-of select="ead/eadheader/filedesc/publicationstmt/date"/>
	</h5>
	
	<ul>
		<b>Contact Information</b>
		
		<dd>Reference Department</dd>
		<dd>Archives of American Art</dd>
		<dd>Smithsonian Institution</dd>
		<dd>Washington. D.C. 20560</dd>
		<dd>www.aaa.si.edu/askus</dd>
	</ul>
	
	<hr></hr>
</xsl:template>

<!--This template rule formats the top-level did element.-->
<xsl:template name="archdesc-did">
		
	<!--For each element of the did, this template inserts the value of the LABEL attribute or, if none is present, a default value.-->
	
	<xsl:for-each select="ead/archdesc/did">
		<table width="100%">
			<tr>
				<td width="5%"></td><td width="20%"></td><td width="75"></td>
			</tr>
			<tr>
				<td colspan="3">
					<h3>
						<a name="a1">
							<xsl:apply-templates select="head"/>
						</a>
					</h3>
				</td>
			</tr>
			<xsl:if test="origination[string-length(text()|*)!=0]">
				<xsl:for-each select="origination">
					<xsl:choose>
						<xsl:when test="@label">
							<tr>
								<td></td>
								<td valign="top">
									<b><xsl:value-of select="@label"/></b>
								</td>
								<td>
									<xsl:apply-templates select="."/>
								</td>
							</tr>
						</xsl:when>
						<xsl:otherwise>
							<tr>
								<td></td>
								<td valign="top">
									<b><xsl:text>Creator: </xsl:text></b>
								</td>
								<td>
									<xsl:apply-templates select="."/>
								</td>
							</tr>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:for-each>
			</xsl:if>
			
			
			<!-- Tests for and processes various permutations of unittitle and unitdate.-->
			<xsl:for-each select="unittitle">
				<xsl:choose>
					<xsl:when test="@label">
						<tr>
							<td></td>
							<td valign="top">
								<b><xsl:value-of select="@label"/></b>
							</td>
							<td>
								<xsl:apply-templates
									select="text() |* [not(self::unitdate)]"/>
							</td>
						</tr>
					</xsl:when>
					<xsl:otherwise>
						<tr>
							<td></td>
							<td valign="top">
								<b><xsl:text>Title: </xsl:text></b>
							</td>
							<td>
								<xsl:apply-templates
									select="text() |* [not(self::unitdate)]"/>
							</td>
						</tr>
					</xsl:otherwise>
				</xsl:choose>
				
				<xsl:if test="child::unitdate">
					<xsl:choose>
						<xsl:when test="./unitdate/@label">
							<tr>
								<td></td>
								<td valign="top">
									<b><xsl:value-of
											select="./unitdate/@label"/></b>
								</td>
								<td>
									<xsl:apply-templates
										select="./unitdate"/>
								</td>
							</tr>
						</xsl:when>
						<xsl:otherwise>
							<tr>
								<td></td>
								<td valign="top">
									<b><xsl:text>Dates: </xsl:text></b>
								</td>
								<td>
									<xsl:apply-templates
										select="./unitdate"/>
								</td>
							</tr>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:if>
			</xsl:for-each>
			
			
			<!-- Processes the unit date if it is not a child of unit title but a child of did, the current context.-->
			<xsl:if test="unitdate">
				<xsl:for-each select="unitdate[string-length(text()|*)!=0]">
					<xsl:choose>
						<xsl:when test="./@label">
							<tr>
								<td></td>
								<td valign="top">
									<b><xsl:value-of select="./@label"/></b>
								</td>
								<td>
									<xsl:apply-templates select="."/>
								</td>
							</tr>
						</xsl:when>
						<xsl:otherwise>
							<tr>
								<td></td>
								<td valign="top">
									<b><xsl:text>Dates: </xsl:text></b>
								</td>
								<td>
									<xsl:apply-templates select="."/>
								</td>
							</tr>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:for-each>
			</xsl:if>
			
			<xsl:if test="abstract[string-length(text()|*)!=0]">
				<xsl:choose>
					<xsl:when test="@label">
						<tr>
							<td></td>
							<td valign="top">
								<b><xsl:value-of select="@label"/></b>
							</td>
							<td>
								<xsl:apply-templates select="abstract"/>
							</td>
						</tr>
					</xsl:when>
					<xsl:otherwise>
						<tr>
							<td></td>
							<td valign="top">
								<b><xsl:text>Abstract: </xsl:text></b>
							</td>
							<td>
								<xsl:apply-templates select="abstract"/>
							</td>
						</tr>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:if>
			
			<xsl:if test="physdesc[string-length(text()|*)!=0]">
				<xsl:choose>
					<xsl:when test="@label">
						<tr>
							<td></td>
							<td valign="top">
								<b><xsl:value-of select="@label"/></b>
							</td>
							<td>
								<xsl:apply-templates select="physdesc"/>
							</td>
						</tr>
					</xsl:when>
					
					<xsl:otherwise>
						<tr>
							<td></td>
							<td valign="top">
								<b><xsl:text>Extent: </xsl:text></b>
							</td>
							<td>
								<xsl:apply-templates select="physdesc"/>
							</td>
						</tr>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:if>
			
			<xsl:if test="langmaterial[string-length(text()|*)!=0]">
				<xsl:choose>
					<xsl:when test="@label">
						<tr>
							<td></td>
							<td valign="top">
								<b><xsl:value-of select="@label"/></b>
							</td>
							<td>
								<xsl:apply-templates select="langmaterial"/>
							</td>
						</tr>
					</xsl:when>
					
					<xsl:otherwise>
						<tr>
							<td></td>
							<td valign="top">
								<b><xsl:text>Language: </xsl:text></b>
							</td>
							<td>
								<xsl:apply-templates select="langmaterial"/>
							</td>
						</tr>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:if>
			
			<xsl:if test="unitid[string-length(text()|*)!=0]">
				<xsl:choose>
					<xsl:when test="@label">
						<tr>
							<td></td>
							<td valign="top">
								<b><xsl:value-of select="@label"/></b>
							</td>
							<td>
								<xsl:apply-templates select="unitid"/>
							</td>
						</tr>
					</xsl:when>
					
					<xsl:otherwise>
						<tr>
							<td></td>
							<td valign="top">
								<b><xsl:text>Identification: </xsl:text></b>
							</td>
							<td>
								<xsl:apply-templates select="unitid"/>
								
							</td>
						</tr>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:if>
			
			<xsl:if test="physloc[string-length(text()|*)!=0]">
				<xsl:choose>
					<xsl:when test="@label">
						<tr>
							<td></td>
							<td valign="top">
								<b><xsl:value-of select="@label"/></b>
							</td>
							<td>
								<xsl:apply-templates select="physloc"/>
							</td>
						</tr>
					</xsl:when>
					
					<xsl:otherwise>
						<tr>
							<td></td>
							<td valign="top">
								<b><xsl:text>Location: </xsl:text></b>
							</td>
							<td>
								<xsl:apply-templates select="physloc"/>
							</td>
						</tr>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:if>
			
			<xsl:if test="note[string-length(text()|*)!=0]">
				<xsl:for-each select="note">
					<xsl:choose>
						<xsl:when test="@label">
							<tr>
								<td></td>
								<td valign="top">
									<b><xsl:value-of select="@label"/></b>
								</td>
							</tr>
							<xsl:for-each select="p">
								<tr>
									<td></td>
									<td valign="top">
										<xsl:apply-templates/>
									</td>
								</tr>
							</xsl:for-each>
						</xsl:when>
						
						<xsl:otherwise>
							<tr>
								<td></td>
								<td valign="top">
									<b>Location:</b>
								</td>
								<td>
									<xsl:apply-templates select="note"/>
								</td>
							</tr>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:for-each>
			</xsl:if>
			
		</table>
		<hr></hr>
		
	</xsl:for-each>
</xsl:template>

<!--This template rule formats a top-level admininfo element.-->
<xsl:template name="archdesc-admininfo">
	<xsl:if
		test="ead/archdesc/acqinfo[string-length(text()|*)!=0] | ead/archdesc/separatedmaterial[string-length(text()|*)!=0] | ead/archdesc/originalsloc[string-length(text()|*)!=0] | ead/archdesc/relatedmaterial[string-length(text()|*)!=0] | ead/archdesc/altformavail[string-length(text()|*)!=0] | ead/archdesc/processinfo[string-length(text()|*)!=0] | ead/archdesc/prefercite[string-length(text()|*)!=0] | ead/archdesc/custodialhist[string-length(text()|*)!=0] | ead/archdesc/appraisal[string-length(text()|*)!=0] | ead/archdesc/accruals[string-length(text()|*)!=0]">
		<h3>
			<a name="a14">
				<b><xsl:text>Administrative Information</xsl:text></b>
			</a>
		</h3>
		<xsl:for-each select="	ead/archdesc/acqinfo|
								ead/archdesc/separatedmaterial|
								ead/archdesc/originalsloc|
								ead/archdesc/relatedmaterial|
								ead/archdesc/altformavail|
								ead/archdesc/processinfo|
								ead/archdesc/prefercite|
								ead/archdesc/accessrestrict|
								ead/archdesc/userestrict|
								ead/archdesc/custodialhist|
								ead/archdesc/appraisal|
								ead/archdesc/accruals">
			<h4 style="margin-left : 15pt">
				<b><xsl:value-of select="head"/></b>
			</h4>
			<xsl:for-each select="p">
				<p style="margin-left : 30pt">
					<xsl:apply-templates select="."/>
				</p>
			</xsl:for-each>
		</xsl:for-each>
		
		<p>
			<a href="#a0">Return to the Table of Contents</a>
		</p>
		<hr></hr>
	</xsl:if>
</xsl:template>

<!-- Loren end insert -->

<!--This template rule formats the top-level bioghist element.-->
<!--This template rule formats the top-level bioghist element.-->
<xsl:template name="archdesc-bioghist">		
	<xsl:if test="ead/archdesc/bioghist[string-length(text()|*)!=0]">
		<xsl:for-each select="ead/archdesc/bioghist">
			<xsl:apply-templates/>
			<p>
				<a href="#a0">Return to the Table of Contents</a>
			</p>
			<hr></hr>
		</xsl:for-each>
	</xsl:if>
</xsl:template>

<xsl:template match="ead/archdesc/bioghist/head">
	<h3>
		<a name="a2">
			<xsl:apply-templates/>
		</a>
	</h3>
</xsl:template>

<xsl:template match="ead/archdesc/bioghist/p">
	<p style="margin-left: 30pt">
		<xsl:apply-templates/>
	</p>
</xsl:template>

<xsl:template match="ead/archdesc/bioghist/chronlist">
	<xsl:apply-templates/>
</xsl:template>
			
<!--This template rule formats the scopecontent element.-->
<xsl:template name="archdesc-scopecontent">
	<xsl:if test="ead/archdesc/scopecontent[string-length(text()|*)!=0]">
		<xsl:for-each select="ead/archdesc/scopecontent">
			<xsl:apply-templates/>
		</xsl:for-each>
		<p>
			<a href="#a0">Return to the Table of Contents</a>
		</p>
		<hr></hr>
	</xsl:if>
</xsl:template>

<xsl:template match="ead/archdesc/scopecontent/head">
	<h3><a name="a3"><xsl:apply-templates/></a></h3>
</xsl:template>

<xsl:template match="ead/archdesc/scopecontent/p">
	<p style="margin-left: 30pt">
		<xsl:apply-templates/>
	</p>
</xsl:template>

<!-- Index Terms -->
<xsl:template name="archdesc-control">
	<xsl:if test="ead/archdesc/controlaccess[string-length(text()|*)!=0]">
		<xsl:for-each select="ead/archdesc/controlaccess">
			<h3>
				<a name="a12">
					<xsl:apply-templates select="head"/>
				</a>
			</h3>
			<p style="padding-left: 30pt;">
				<xsl:apply-templates select="p"/>
			</p>
			
			<xsl:for-each select="./controlaccess">
				<h4 style="padding-left: 30pt; padding-bottom: 0; margin-bottom:0;"><xsl:apply-templates select="head"/></h4>
				
				<ul style="list-style:none;">
					<xsl:for-each select="subject |corpname | persname | famname| genreform | title | geogname | occupation">
						<xsl:sort select="."/>
						<li style="padding-left: 30pt;">
							<xsl:apply-templates select="."/>									
						</li>
					</xsl:for-each>							
				</ul>
			</xsl:for-each>
		</xsl:for-each>
		<p>
			<a href="#a0">Return to the Table of Contents</a>
		</p>
		<hr></hr>
	</xsl:if>
</xsl:template>
	
<!-- This formats an arrangement list embedded in a scope content statement.-->
<xsl:template match="ead/archdesc/scopecontent/arrangement">
	<xsl:for-each select="p">
		<p style="margin-left: 30pt">
			<xsl:apply-templates select="."/>
		</p>
	</xsl:for-each>
	<xsl:for-each select="list">
		<dl>
			<xsl:for-each select="item">
				<dd style="margin-left: 30pt">
					<a><xsl:attribute name="href">#series<xsl:number/></xsl:attribute><xsl:apply-templates select="."/></a>
				</dd>
			</xsl:for-each>				
		</dl>
	</xsl:for-each>
</xsl:template>


<!--This template rule formats the arrangement element.-->
<xsl:template name="archdesc-arrangement">
	<xsl:if test="ead/archdesc/arrangement[string-length(text()|*)!=0]">
		<xsl:for-each select="ead/archdesc/arrangement">
			<h3>
				<a name="a4">
					<xsl:apply-templates select="head"/>
				</a>
			</h3>
	
			<xsl:for-each select="p">
				<p style="margin-left: 30pt">
					<xsl:apply-templates select="."/>
				</p>
			</xsl:for-each>
				
			<xsl:for-each select="list">
				<p style="margin-left: 30pt">
					<xsl:apply-templates select="head"/>						
				</p>
				<ul style="list-style: none;">
					<xsl:for-each select="item">
						<li style="padding-left: 30pt;">
							<a><xsl:attribute name="href">#series<xsl:number/></xsl:attribute><xsl:apply-templates select="."/></a>							
						</li>
					</xsl:for-each>						
				</ul>
			</xsl:for-each>
		</xsl:for-each>
		<p>
			<a href="#a0">Return to the Table of Contents</a>
		</p>
		<hr></hr>
	</xsl:if>
</xsl:template>

<!--This template rule formats the top-level otherfindaid element.-->
<xsl:template name="archdesc-otherfindaid">
	<xsl:if test="ead/archdesc/otherfindaid[string-length(text()|*)!=0]">
		<xsl:for-each select="ead/archdesc/otherfindaid">
			<h3>
				<a name="a8">
					<b><xsl:apply-templates select="head"/></b>
				</a>
			</h3>
			<xsl:for-each select="p">
				<p style="margin-left : 30pt">
					<xsl:apply-templates select="."/>
				</p>
			</xsl:for-each>
		</xsl:for-each>
		<p>
			<a href="#a0">Return to the Table of Contents</a>
		</p>
		<hr></hr>
	</xsl:if>
</xsl:template>

<xsl:template name="dsc">
	<xsl:for-each select="ead/archdesc/dsc">
		<h3><a name="a23"><xsl:apply-templates select="head"/></a></h3>
		
		<xsl:if test="string-length(p)!=0">
			<p style="margin-left: 25 pt">
				<i><xsl:apply-templates select="p"/></i>
			</p>
		</xsl:if>

		<xsl:apply-templates select="c01"/>
		
	</xsl:for-each>
</xsl:template>

<xsl:template name="unittitle-stuff">
	<!--This named template defines the processing of unittitle and unitdates in a way that
	is applicable at all component levels.	It is invoked throughout the following templates.
	Unitdates may be the children either of unittitle or did.  This templates sorts those options
	out.  It also includes conditional processing to handle situations where unitdate elements are
	included in the markup but empty of PCDATA content.-->
	<xsl:choose>
		<!--When unitdate is a child of unittitle.-->
		<xsl:when test="unittitle/unitdate">
			<xsl:for-each select="unittitle">
				
				<!--Inserts the text of unittitle and any children other than unitdate.-->
				<xsl:apply-templates select="text()|*[not(self::unitdate)]"/>
				<!--Tests to see if the unitdate has content and adds it and separating space
				if it does.-->
				<xsl:if test="string-length(./unitdate)!=0">
					<xsl:text>
					</xsl:text>
					<xsl:apply-templates select="./unitdate"/>
				</xsl:if>
			</xsl:for-each>
		</xsl:when>
		<!--When unitdate is a child of did.-->
		<xsl:otherwise>
			<xsl:apply-templates select="unittitle"/>
			<xsl:if test="string-length(unitdate)!=0">
				<xsl:text>
				</xsl:text>
				<xsl:apply-templates select="unitdate"/>
			</xsl:if>
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>


<!--This template  creates a table for each c01 and applies templates for c01 children.-->
<xsl:template match="c01|c02|c03|c04|c05|c06">
	<xsl:variable name="currentComponent" select="local-name()" />
	
	<!--Creates two variables for testing container values.-->
	<!-- changed these variables to refer to the nodes, not hold
	their values -->
	
	<!-- Added variables to allow for mixed container types -->
	<xsl:variable name="boxnumber" select="did/container[@type='box']"/>
	<xsl:variable name="foldernumber" select="did/container[@type='folder']"/>
	
	<xsl:variable name="reelnumber" select="did/container[@type='reel']"/>
	<xsl:variable name="framenumber" select="did/container[@type='frame']"/>

	<xsl:variable name="prevContainerNumber">
		<xsl:choose>
			<xsl:when test="string-length($boxnumber)">
				<xsl:choose>
					<xsl:when test="string-length(parent::node()/did/container[@type='box']) = 0">
						<xsl:value-of select="number(preceding-sibling::node()[1]/did/container[@type='box'])" />
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="number(parent::node()/did/container[@type='box'])" />																			
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:when test="string-length($reelnumber)">
				<xsl:choose>
					<xsl:when test="string-length(parent::node()/did/container[@type='reel']) = 0">
						<xsl:value-of select="number(preceding-sibling::node()[1]/did/container[@type='reel'])" />
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="number(parent::node()/did/container[@type='reel'])" />																			
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:otherwise><xsl:text></xsl:text></xsl:otherwise>
		</xsl:choose>
	</xsl:variable>

	<xsl:variable name="prevSubContainerNumber">
		<xsl:choose>
			<xsl:when test="string-length($boxnumber) and string-length($reelnumber)">
				<xsl:choose>
					<xsl:when test="string-length(preceding-sibling::node()[1]/did/container[@type='reel'])">
						<xsl:value-of select="number(preceding-sibling::node()[1]/did/container[@type='reel'])" />
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="number(parent::node()/did/container[@type='reel'])" />																			
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:when test="string-length($foldernumber)">
				<xsl:choose>
					<xsl:when test="string-length(parent::node()/did/container[@type='folder']) = 0">
						<xsl:value-of select="number(preceding-sibling::node()[1]/did/container[@type='folder'])" />
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="number(parent::node()/did/container[@type='folder'])" />																			
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:when test="string-length($framenumber)">
				<xsl:choose>
					<xsl:when test="string-length(parent::node()/did/container[@type='frame']) = 0">
						<xsl:value-of select="number(preceding-sibling::node()[1]/did/container[@type='frame'])" />
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="number(parent::node()/did/container[@type='frame'])" />																			
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:otherwise><xsl:text></xsl:text></xsl:otherwise>
		</xsl:choose>
	</xsl:variable>


	<xsl:choose>
		<xsl:when test="@level!='' or @otherlevel!=''">
			<h3>
				<xsl:variable name="seriesAnchorPrefix">
					<xsl:call-template name="generateAnchorString">
						<xsl:with-param name="currentComponent" select="local-name()" />
					</xsl:call-template>
				</xsl:variable>
				
				<a><xsl:attribute name="name"><xsl:value-of select="$seriesAnchorPrefix" /></xsl:attribute><xsl:text>  </xsl:text></a>
				<xsl:apply-templates select="did/head"/>					
				<xsl:apply-templates select="did/unitid"/>
				<xsl:for-each select="did">
					<xsl:call-template name="unittitle-stuff"/>
				</xsl:for-each>
				<xsl:text> </xsl:text>
				<xsl:apply-templates select="did/physdesc"/>
			</h3>
			
			<xsl:for-each select="scopecontent/note/p|scopecontent/p">
				<p>
					<xsl:apply-templates select="."/>
				</p>
			</xsl:for-each>

			<xsl:apply-templates select="arrangement">
				<xsl:with-param name="currentComponent" select="local-name()" />			
			</xsl:apply-templates>

		</xsl:when>
		<xsl:otherwise>
			<table>
				<xsl:choose>
					
					<!--The first option selects cases where either the value of the box container or the folder
					container is the same as that of a previous component.	In that case, no column labels are added and only the folder number appears
					along with the other component data.-->
					
					<xsl:when test="	( 	
											(string-length($boxnumber) and not($boxnumber = $prevContainerNumber)) or 
											(not(string-length($boxnumber)) and string-length($reelnumber) and not($reelnumber = $prevContainerNumber))) 
											and
										(
											count(../did/container) = 0 or
											(count(../did/container) = 1 and count(did/container) = 1) or
											(count(../did/container) = 2 and count(did/container) = 2 and string-length(../did/container[2]) != 0) 
										)
									">
						<!--Selects cases where the value of the box or reel container is not the same as
						that of a previous component.	In that case, column labels are added and both the						
						box and reel numbers appear along with the other component data.-->
						<tr>
							<td style="width:75px">
								<br/>
								<xsl:choose>
									<xsl:when test="string-length($boxnumber)">
										<b>Box</b>												
									</xsl:when>
									<xsl:when test="string-length($reelnumber)">
										<b>Reel</b>
									</xsl:when>
								</xsl:choose>												
							</td>
							<td style="width:75px">
								<br/>
								<xsl:choose>
									<xsl:when test="string-length($boxnumber) and string-length($reelnumber)">
										<b>Reel</b>
									</xsl:when>										
									<xsl:when test="string-length($foldernumber)">
										<b>Folder</b>
									</xsl:when>
									<xsl:when test="string-length($framenumber)">
										<b>Frame</b>
									</xsl:when>										
								</xsl:choose>
							</td>
							<td><br /></td>											
						</tr>
					</xsl:when>
				</xsl:choose>
				<tr>
					<td style="width:75px">
						<xsl:choose>
							<xsl:when test="	not(
													(
													(string-length($boxnumber) and not($boxnumber = $prevContainerNumber)) or 
													(not(string-length($boxnumber)) and string-length($reelnumber) and not($reelnumber = $prevContainerNumber))) and
													(
														count(../did/container) = 0 or
														(count(../did/container) = 1 and count(did/container) = 1) or
														(count(../did/container) = 2 and count(did/container) = 2 and string-length(../did/container[2]) != 0) 
													)
												)
									">
								<br />				
							</xsl:when>
							<xsl:when test="string-length($boxnumber)">
								<xsl:value-of select="$boxnumber" />												
							</xsl:when>
							<xsl:when test="string-length($reelnumber)">
								<xsl:value-of select="$reelnumber" />
							</xsl:when>
						</xsl:choose>												
					</td>
					<td style="width:75px">
						<xsl:choose>
							<xsl:when test="	not(
													(string-length($boxnumber) and string-length($reelnumber) and not($reelnumber = $prevSubContainerNumber)) or 													
													(string-length($foldernumber) and not($foldernumber = $prevSubContainerNumber)) or
													(string-length($framenumber) and not($framenumber = $prevSubContainerNumber))
												)
									">
								<br />				
							</xsl:when>
							<xsl:when test="string-length($boxnumber) and string-length($reelnumber)">
								<xsl:value-of select="$reelnumber" />
							</xsl:when>										
							<xsl:when test="string-length($foldernumber)">
								<xsl:value-of select="$foldernumber" />
							</xsl:when>
							<xsl:when test="string-length($framenumber)">
								<xsl:value-of select="$framenumber" />
							</xsl:when>
							<xsl:otherwise>
								<br />
							</xsl:otherwise>										
						</xsl:choose>
					</td>											
		
					<xsl:variable name="headingtext">
						<xsl:apply-templates select="did/unitid"/>
						<xsl:for-each select="did">
							<xsl:call-template name="unittitle-stuff"/>
						</xsl:for-each>
						<xsl:text> </xsl:text>
						<xsl:apply-templates select="did/physdesc"/>
						<xsl:apply-templates select="did/abstract"/>										
					</xsl:variable>								
					
					<td>
						<xsl:variable name="componentLevel">
							<xsl:choose>
								<xsl:when test="((string-length(current()/../@level)) or (string-length(current()/../@otherlevel)))">
									<xsl:text>0</xsl:text>
								</xsl:when>
								<xsl:when test="((string-length(current()/../../@level)) or (string-length(current()/../../@otherlevel)))">
									<xsl:text>1</xsl:text>
								</xsl:when>
								<xsl:when test="((string-length(current()/../../../@level)) or (string-length(current()/../../../@otherlevel)))">
									<xsl:text>2</xsl:text>
								</xsl:when>
								<xsl:when test="((string-length(current()/../../../../@level)) or (string-length(current()/../../../../@otherlevel)))">
									<xsl:text>3</xsl:text>
								</xsl:when>
								<xsl:when test="((string-length(current()/../../../../../@level)) or (string-length(current()/../../../../../@otherlevel)))">
									<xsl:text>4</xsl:text>
								</xsl:when>
								<xsl:otherwise>
									<xsl:text>5</xsl:text>
								</xsl:otherwise>
							</xsl:choose>
								
						</xsl:variable>
												
						<xsl:variable name="indentLevel">
							<xsl:value-of select="$componentLevel" />										
						</xsl:variable>
						
						<xsl:variable name="indentValue">
							<xsl:value-of select="$indentLevel*30" />
						</xsl:variable>
					
						<div><xsl:attribute name="style"><xsl:text>padding-left:</xsl:text><xsl:value-of select="$indentValue" /><xsl:text>pt;</xsl:text></xsl:attribute>
							<xsl:value-of select="$headingtext" /> 
						</div>
						<xsl:if test="string-length(scopecontent)">
							<div><xsl:attribute name="style"><xsl:text>padding-left:</xsl:text><xsl:value-of select="$indentValue" /><xsl:text>pt;</xsl:text></xsl:attribute>
								<xsl:for-each select="scopecontent">
									<xsl:apply-templates/>
								</xsl:for-each>
							</div>								
						</xsl:if>
					</td>							
				</tr>					
			</table>
		</xsl:otherwise>
	</xsl:choose>

	<!-- Should be an easier way to do this, but hasn't worked so far -->
	<xsl:choose>
		<xsl:when test="local-name()='c01'">
			<xsl:apply-templates select="c02" />
		</xsl:when>
		<xsl:when test="local-name()='c02'">
			<xsl:apply-templates select="c03" />				
		</xsl:when>
		<xsl:when test="local-name()='c03'">
			<xsl:apply-templates select="c04" />				
		</xsl:when>
		<xsl:when test="local-name()='c04'">
			<xsl:apply-templates select="c05" />				
		</xsl:when>
		<xsl:when test="local-name()='c05'">
			<xsl:apply-templates select="c06" />				
		</xsl:when>
	</xsl:choose>

</xsl:template>

<xsl:template match="   
						c01/bioghist | 
						c01/arrangement |
						c02/bioghist | 
						c02/arrangement |
						c03/bioghist | 
						c03/arrangement |
						c04/bioghist | 
						c04/arrangement |
						c05/bioghist | 
						c05/arrangement |
						c06/bioghist | 
						c06/arrangement 
	">		
	<xsl:for-each select="p">
		<p><xsl:apply-templates select="."/></p>
	</xsl:for-each>
</xsl:template>

<xsl:template match="
					c01/arrangement/p/list |
					c02/arrangement/p/list |
					c03/arrangement/p/list |
					c04/arrangement/p/list |
					c05/arrangement/p/list |
					c06/arrangement/p/list
	">
	<xsl:param name="currentComponent" />		
	
	<xsl:variable name="seriesAnchorPrefix">
		<xsl:call-template name="generateAnchorString">
			<xsl:with-param name="currentComponent" select="$currentComponent" />
		</xsl:call-template>
	</xsl:variable>
	
	<ul style="list-style:none">
		<xsl:for-each select="item">

			<!-- ָAppend the number for the current item -->
			<xsl:variable name="seriesAnchor">
				<xsl:variable name="itemCount">
					<xsl:number count="item" from="list"/>
				</xsl:variable>
				<xsl:value-of select="concat('#',$seriesAnchorPrefix,'_',string($itemCount))" />								
			</xsl:variable>
										
			<li>
				<a>
					<xsl:attribute name="href"><xsl:value-of select="$seriesAnchor" /></xsl:attribute>
					<xsl:value-of select="."/>
				</a>					
			</li>
		</xsl:for-each>
	</ul>
</xsl:template>

<xsl:template name="generateAnchorString">
	<xsl:param name="currentComponent" />
	
	<!-- Determine the anchor prefix -->
	<!--Creates a link that points to the series -->
	<xsl:variable name="seriesCount">
		<xsl:number count="c01" from="dsc"/>
	</xsl:variable>
	<xsl:variable name="seriesAnchorPrefix" select="concat('series',string($seriesCount))" />

	<xsl:variable name="componentLevel">
		<!-- Grabs the left most number from the element name to give us -->
		<xsl:value-of select="number(substring($currentComponent,3,1))" />
	</xsl:variable>
	<xsl:variable name="workingAnchorPrefix">
		<xsl:variable name="workingAnchorPrefix" select="''" />
		
		<!-- If the c0x level is greater than 1, grab the distance from the nearest c01 to give the sub-series number -->
		<xsl:choose>
			<xsl:when test="$componentLevel &gt; 1">
				<xsl:variable name="subseriesCount">
					<xsl:number count="c02" from="c01"/>
				</xsl:variable>						
				<xsl:value-of select="concat($workingAnchorPrefix,'_',string($subseriesCount))" />								
			</xsl:when>						
		</xsl:choose>

		<!-- If the c0x level is greater than 2, grab the distance from the nearest c01 to give the sub-series number -->
		<xsl:choose>
			<xsl:when test="$componentLevel &gt; 2">
				<xsl:variable name="subsubseriesCount">
					<xsl:number count="c03" from="c02"/>
				</xsl:variable>						
				<xsl:value-of select="concat($workingAnchorPrefix,'_',string($subsubseriesCount))" />								
			</xsl:when>						
		</xsl:choose>
		
		
		<!-- If the c0x level is greater than 3, grab the distance from the nearest c01 to give the sub-series number -->
		<xsl:choose>
			<xsl:when test="$componentLevel &gt; 3">
				<xsl:variable name="subsubsubseriesCount">
					<xsl:number count="c04" from="c03"/>
				</xsl:variable>
				<xsl:value-of select="concat($workingAnchorPrefix,'_',string($subsubsubseriesCount))" />								
			</xsl:when>						
		</xsl:choose>
	</xsl:variable>
	<xsl:value-of select="concat($seriesAnchorPrefix,$workingAnchorPrefix)" />			
</xsl:template>

	<!--This template rule formats the top-level bibliography element.-->
	<xsl:template name="archdesc-bibliography">
		<xsl:if test="ead/archdesc/bibliography[string-length(text()|*)!=0]">
			<xsl:for-each select="ead/archdesc/bibliography">
				<h3>
					<a name="a10">
						<b><xsl:apply-templates select="head"/></b>
					</a>
				</h3>
				<xsl:for-each select="p">
					<xsl:for-each select="bibref">
						<p style="margin-left : 30pt">
							<xsl:apply-templates select="."/>
						</p>
					</xsl:for-each>
				</xsl:for-each>
			</xsl:for-each>
			<p>
				<a href="#a0">Return to the Table of Contents</a>
			</p>
			<hr></hr>
		</xsl:if>
	</xsl:template>
	
	<!--This template rule formats the top-level odd element.-->
	<xsl:template name="archdesc-odd">
		<xsl:if test="//odd[string-length(text()|*)!=0]">
			<xsl:for-each select="//odd">
				<a name="{@id}"><xsl:text> </xsl:text></a>
				<xsl:if test="string-length(head)">
					<h3>
						<b><xsl:apply-templates select="head"/></b>
					</h3>
				</xsl:if>
				<xsl:for-each select="p">
					<p style="margin-left : 30pt">
						<xsl:apply-templates select="."/>
					</p>
				</xsl:for-each>
			</xsl:for-each>
			<p>
				<a href="#a0">Return to the Table of Contents</a>
			</p>
			<hr></hr>
		</xsl:if>
	</xsl:template>

	<xsl:template match="//odd/chronlist">
		<xsl:apply-templates/>
	</xsl:template>
	
	<!-- Loren added blockquote template -->
	<xsl:template match="blockquote">
		<blockquote>
			<p style="margin-left: 30pt">
				<xsl:apply-templates/>
			</p>
		</blockquote>
	</xsl:template>
	
	
	<!-- The following templates format the display of various RENDER attributes.-->
	
	<xsl:template match="*/title">
		<xsl:apply-templates/>
	</xsl:template>
	
	<xsl:template match="*/emph">
		<xsl:apply-templates/>
	</xsl:template>
	
	<xsl:template match="*[@render='bold']">
		<b>
			<xsl:apply-templates />
		</b>
	</xsl:template>
	
	<xsl:template match="*[@render='italic']">
		<i>
			<xsl:apply-templates />
		</i>
	</xsl:template>
	
	<xsl:template match="*[@render='underline']">
		<u>
			<xsl:apply-templates />
		</u>
	</xsl:template>
	
	<xsl:template match="*[@render='sub']">
		<sub>
			<xsl:apply-templates />
		</sub>
	</xsl:template>
	
	<xsl:template match="*[@render='super']">
		<super>
			<xsl:apply-templates />
		</super>
	</xsl:template>
	
	<xsl:template match="*[@render='quoted']">
		<xsl:text>"</xsl:text>
		<xsl:apply-templates />
		<xsl:text>"</xsl:text>
	</xsl:template>
	
	<xsl:template match="*[@render='boldquoted']">
		<b>
			<xsl:text>"</xsl:text>
			<xsl:apply-templates />
			<xsl:text>"</xsl:text>
		</b>
	</xsl:template>
	
	<xsl:template match="*[@render='boldunderline']">
		<b>
			<u>
				<xsl:apply-templates />
			</u>
		</b>
	</xsl:template>
	
	<xsl:template match="*[@render='bolditalic']">
		<b>
			<i>
				<xsl:apply-templates />
			</i>
		</b>
	</xsl:template>
	
	<xsl:template match="*[@render='boldsmcaps']">
		<font style="font-variant: small-caps">
			<b>
				<xsl:apply-templates />
			</b>
		</font>
	</xsl:template>
	
	<xsl:template match="*[@render='smcaps']">
		<font style="font-variant: small-caps">
			<xsl:apply-templates />
		</font>
	</xsl:template>
	
	<!-- This template converts a Ref element into an internal anchor.-->
	
	<xsl:template match="//ref">
		<xsl:variable name="target">
			<xsl:value-of select="@target"/>
		</xsl:variable>
		<a href="#{$target}">
			<xsl:apply-templates />
		</a>
	</xsl:template>
	
	<!-- This template converts a ExtRef element into an external anchor.-->
	
	<xsl:template match="//extref">
		<xsl:variable name="href">
			<xsl:value-of select="@href"/>
		</xsl:variable>
		<a href="{$href}">
			<xsl:apply-templates />
		</a>
	</xsl:template>
	
	<!-- Converts an ID attribute into the name attribute of an HTML anchor to form the target of a Ref element.-->
	
	<xsl:template match="*[@id]">
		<a name="{@id}">
			<xsl:apply-templates />
		</a>
	</xsl:template>
	
	
	<!--Formats a simple table. The width of each column is defined by the colwidth attribute in a colspec element.-->
	<xsl:template match="*/table">
		<xsl:for-each select="tgroup">
			<table width="100%">
				<tr>
					<xsl:for-each select="colspec">
						<td width="{@colwidth}"></td>
					</xsl:for-each>
				</tr>
				<xsl:for-each select="thead">
					<xsl:for-each select="row">
						<tr>
							<xsl:for-each select="entry">
								<td valign="top">
									<b>
										<xsl:apply-templates />
									</b>
								</td>
							</xsl:for-each>
						</tr>
					</xsl:for-each>
				</xsl:for-each>
				
				<xsl:for-each select="tbody">
					<xsl:for-each select="row">
						<tr>
							<xsl:for-each select="entry">
								<td valign="top">
									<xsl:apply-templates />
								</td>
							</xsl:for-each>
						</tr>
					</xsl:for-each>
				</xsl:for-each>
			</table>
		</xsl:for-each>
	</xsl:template>
	
	<!--This template rule formats a chronlist element.-->
	
	<xsl:template match="//chronlist">
		<table width="100%">
			<tr>
				<td width="5%">
				</td>
				<td width="30%">
				</td>
				<td width="65%">
				</td>
			</tr>
			
			<xsl:for-each select="listhead">
				<tr>
					<td></td>
					<td>
						<b>
							<xsl:apply-templates select="head01"/>
						</b>
					</td>
					<td>
						<b>
							<xsl:if test="head02[string-length(text()|*)!=0]">
								<xsl:apply-templates select="head02"/>
							</xsl:if>
						</b>
					</td>
				</tr>
			</xsl:for-each>
			
			<xsl:for-each select="chronitem">
				<tr>
					<td></td>
					<td valign="top">
						<xsl:apply-templates select="date"/>
					</td>
					<td valign="top">
						<xsl:apply-templates select="event"/>
					</td>
				</tr>
			</xsl:for-each>
		</table>
	</xsl:template>
	
	<!--This template rule formats a list element.-->
	<xsl:template match="//scopecontent/p/list|//odd/p/list">
		<xsl:if test="string-length(head)">
			<h4><xsl:apply-templates select="head"/></h4>
		</xsl:if>
		<dl>
		<xsl:for-each select="item">
			<dd style="margin-left: 30pt;">
				<xsl:apply-templates select="."/>
			</dd>
		</xsl:for-each>				
		</dl>
	</xsl:template>
</xsl:stylesheet>